package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"serverGo/graph/model"
	u "serverGo/utils"
	"strconv"
)

// GetGameDetails is the resolver for the getGameDetails field.
func (r *queryResolver) GetGameDetails(ctx context.Context, steamAppid int) (*model.GDetailsRes, error) {
	end, err := u.MakePublicEndpoint("getGameDetails")

	if err != nil {
		return nil, err
	}

	end.AddQueries(u.QueriesStruct{Key: "appids", Val: strconv.Itoa(steamAppid)})

	go func() {
		r.Resolver.FetchAPI(ctx, strconv.Itoa(steamAppid), end.URL.String(), r.ResChan)
	}()

	resp := <-r.ResChan

	var wrapper map[string]*model.GDetailsRes

	if err := json.Unmarshal(resp.BodyResponse, &wrapper); err != nil {
		return nil, err
	}

	wrapperInfo := wrapper[strconv.Itoa(steamAppid)]
	if wrapperInfo != nil {
		return wrapperInfo, nil
	}
	return nil, errors.New("couldn't extract the data from the json")

}

// GetUserOwnedGames is the resolver for the getUserOwnedGames field.
func (r *queryResolver) GetUserOwnedGames(ctx context.Context, steamid int) ([]*model.UOGamesRes, error) {
	return nil, nil
}

// GetPlayerSummaries is the resolver for the getPlayerSummaries field.
func (r *queryResolver) GetPlayerSummaries(ctx context.Context, steamids []int) ([]*model.PSummariesRes, error) {
	panic(fmt.Errorf("not implemented: GetPlayerSummaries - getPlayerSummaries"))
}

// GetFriendList is the resolver for the getFriendList field.
func (r *queryResolver) GetFriendList(ctx context.Context, steamids []int) ([]*model.FListRes, error) {
	panic(fmt.Errorf("not implemented: GetFriendList - getFriendList"))

}

type ResChanType struct {
	BodyResponse []byte
	Reponse      *http.Response
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver {
	return &queryResolver{Resolver: r, ResChan: make(chan *ResChanType)}
}

type queryResolver struct {
	*Resolver
	ResChan chan *ResChanType
}
