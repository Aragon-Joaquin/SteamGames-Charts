package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"errors"
	"net/http"
	"serverGo/graph/model"
	u "serverGo/utils"
	"strconv"
)

// GetGameDetails is the resolver for the getGameDetails field.
func (r *queryResolver) GetGameDetails(ctx context.Context, steamAppid int) (*model.GDetailsRes, error) {
	end, err := u.MakePublicEndpoint("getGameDetails")

	if err != nil {
		return nil, err
	}

	end.AddQueries(u.QueriesStruct{Key: "appids", Val: strconv.Itoa(steamAppid)})

	go func() {
		r.Resolver.FetchAPI(ctx, strconv.Itoa(steamAppid), end.URL.String(), r.ResChan)
	}()

	resp := <-r.ResChan
	var wrapper map[string]*model.GDetailsRes

	val, err := u.UnmarshalMapping(wrapper, &resp.BodyResponse, strconv.Itoa(steamAppid))

	if err != nil {
		return nil, err
	}

	return val, nil
}

// GetUserOwnedGames is the resolver for the getUserOwnedGames field.
func (r *queryResolver) GetUserOwnedGames(ctx context.Context, steamid int) (*model.UOGamesRes, error) {
	end, err := u.MakePublicEndpoint("getOwnGames")

	if err != nil {
		return nil, err
	}
	steamidString := strconv.Itoa(steamid)

	end.AddQueries(
		u.QueriesStruct{Key: "steamid", Val: steamidString},
		u.QueriesStruct{Key: "include_played_free_games", Val: "true"},
		u.QueriesStruct{Key: "include_appinfo", Val: "true"})

	go func() {
		r.Resolver.FetchAPI(ctx, steamidString, end.URL.String(), r.ResChan)
	}()

	resp := <-r.ResChan
	var wrapper *model.UOGamesRes

	val, err := u.UnmarshalWithoutMapping(wrapper, &resp.BodyResponse, steamidString)

	if err != nil {
		return nil, err
	}

	return val, nil
}

// GetPlayerSummaries is the resolver for the getPlayerSummaries field.
func (r *queryResolver) GetPlayerSummaries(ctx context.Context, steamids []int) (*model.PSummariesRes, error) {
	if len(steamids) >= u.MAX_PLAYERS_SUMMARIES || len(steamids) <= 0 {
		return nil, errors.New("can only fetch between 1 and " + strconv.Itoa(u.MAX_PLAYERS_SUMMARIES) + " steam profiles.")
	}

	end, err := u.MakePublicEndpoint("getPlayer")
	if err != nil {
		return nil, err
	}

	separator := u.SliceIntoString(steamids)

	end.AddQueries(u.QueriesStruct{Key: "steamids", Val: separator})

	go func() {
		r.Resolver.FetchAPI(ctx, separator, end.URL.String(), r.ResChan)
	}()

	resp := <-r.ResChan
	var wrapper *model.PSummariesRes

	val, err := u.UnmarshalWithoutMapping(wrapper, &resp.BodyResponse, separator)

	if err != nil {
		return nil, err
	}

	return val, nil
}

// GetFriendList is the resolver for the getFriendList field.
func (r *queryResolver) GetFriendList(ctx context.Context, steamids []int) (*model.FListRes, error) {
	_, err := u.MakePublicEndpoint("getFriends")

	if err != nil {
		return nil, err
	}

	return nil, nil

}

type ResChanType struct {
	BodyResponse []byte
	Reponse      *http.Response
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver {
	return &queryResolver{Resolver: r, ResChan: make(chan *ResChanType)}
}

type queryResolver struct {
	*Resolver
	ResChan chan *ResChanType
}
